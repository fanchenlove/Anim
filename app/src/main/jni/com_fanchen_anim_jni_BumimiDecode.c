/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <android/log.h>
#include "md5.h"
#include "base64.h"
#include "urlutil.h"

#define TAG "anim" // 这个是自定义的LOG的标识
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGI类型
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义LOGW类型
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义LOGE类型
#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义LOGF类型

/**
 *
 */
char* jstringToChar(JNIEnv* env, jstring jstr);

/*
 * Class:     com_fanchen_anim_jni_BumimiDecode
 * Method:    decodeInfoJson
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_fanchen_anim_jni_BumimiDecode_decodeInfoJson
  (JNIEnv *env, jclass jc, jstring json){
    //对数据进行解密
    //解密key
    unsigned char encrypt[] = "base64_encode";
    //计算key的md5
    int len = strlen((char *) encrypt);
    unsigned char decrypt[16];
    MD5_CTX md5;
    MD5Init(&md5);
    MD5Update(&md5, encrypt, strlen((char *) encrypt));
    MD5Final(&md5, decrypt);
    //这里将MD5转成32位字符串
    char str1[33];
    char str2[10];
    strcpy(str1, "");
    int i;
    for (i = 0; i < 16; i++) {
        sprintf(str2, "%02x", decrypt[i] & 0x0ff);
        strcat(str1, str2);
    }
    //将jString转成jchar*
    const jchar *chars1 = (*env)->GetStringChars(env, json, 0);
    int var;
    jsize lenght1 = (*env)->GetStringLength(env, json);
    jchar chars3[lenght1];
    //遍历解密数据
    //数据解密后还需要进行一次base64解码
    for (var = 0; var < lenght1; var++) {
        int k = var % 32;
        uint16_t de = chars1[var] ^ str1[k];
        chars3[var] = de;
    }
    //释放资源
//	(*env)->ReleaseStringCritical(env, json, chars1);
    //将jchar*转成jstring，方便后续base64操作
    jstring js4 = (*env)->NewString(env, chars3, lenght1);

    //jstring转char*
    char* chars4 = jstringToChar(env, js4);
    //base64解码
    char* chars5 = Decbase64(chars4, strlen(chars4));
    //转jstring
    jstring js5 = (*env)->NewStringUTF(env, chars5);
    //释放资源
//	(*env)->ReleaseStringUTFChars(env, js5, chars5);
    return js5;
}

/*
 * Class:     com_fanchen_anim_jni_BumimiDecode
 * Method:    decodeUrlJson
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_fanchen_anim_jni_BumimiDecode_decodeUrlJson
  (JNIEnv *env, jclass jc, jstring js){
    char* rtn1 = NULL;
    char* rtn2 = NULL;
    const char* chars1 = jstringToChar(env, js);
    int alen = strlen(chars1);
    if (alen > 0) {
        if ((rtn1 = (char*) malloc(alen + 1)) == NULL) {
            return (*env)->NewStringUTF(env, "");
        }
        if ((rtn2 = (char*) malloc(alen - 3)) == NULL) {
            return (*env)->NewStringUTF(env, "");
        }
        memcpy(rtn1, chars1, 3);
        memcpy(rtn2, chars1 + 4, alen - 4);
        rtn1[3] = 0;
        rtn2[alen - 4] = 0;
    }
    strcat(rtn1, rtn2);
    rtn1[alen] = 0;
    char* rtn3 = Decbase64(rtn1, strlen(rtn1));
    jstring jsonurl = (*env)->NewStringUTF(env, rtn3);
    //释放资源
//	(*env)->ReleaseStringUTFChars(env, jsonurl, rtn3);
    return jsonurl;
}

/*
 * Class:     com_fanchen_anim_jni_BumimiDecode
 * Method:    signBiliParameter
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_fanchen_anim_jni_BumimiDecode_signBiliParameter
  (JNIEnv *env , jclass jc, jstring js1){
    char* charParameter = jstringToChar(env, js1);
    char* encryptkey = "f7d9146f9363f3407d31098918493336";
    int len = strlen((char*)encryptkey) + strlen((char*)charParameter);
    char* signstr = NULL;
    if (len > 0) {
        if ((signstr = (char*) malloc(len + 1)) == NULL) {
            return (*env)->NewStringUTF(env, "");
        }
        strcpy(signstr, "");
        strcat(signstr, charParameter);
        strcat(signstr, encryptkey);
        signstr[len] = 0;
    }
    unsigned char decrypt[16];
    MD5_CTX md5;
    MD5Init(&md5);
    MD5Update(&md5, signstr, strlen(signstr));
    MD5Final(&md5, decrypt);
    //这里将MD5转成32位字符串
    char str1[33];
    char str2[10];
    strcpy(str1, "");
    int i;
    for (i = 0; i < 16; i++) {
        sprintf(str2, "%02x", decrypt[i] & 0x0ff);
        strcat(str1, str2);
    }
    jstring sign = (*env)->NewStringUTF(env, str1);
    //LOGE("sign ===> %s", str1);
    //释放资源
    //(*env)->ReleaseStringUTFChars(env, sign, str1);
    return sign;
}

char* jstringToChar(JNIEnv* env, jstring jstr) {
  char* rtn = NULL;
  jclass clsstring = (*env)->FindClass(env, "java/lang/String");
  jstring strencode = (*env)->NewStringUTF(env, "UTF-8");
  jmethodID mid = (*env)->GetMethodID(env, clsstring, "getBytes", "(Ljava/lang/String;)[B");
  jbyteArray barr = (jbyteArray)(*env)->CallObjectMethod(env, jstr, mid, strencode);
  jsize alen = (*env)->GetArrayLength(env, barr);
  jbyte* ba = (*env)->GetByteArrayElements(env, barr, JNI_FALSE);
  if (alen > 0) {
    rtn = (char*) malloc(alen + 1);
    memcpy(rtn, ba, alen);
    rtn[alen] = 0;
  }
  //释放资源
  (*env)->ReleaseByteArrayElements(env, barr, ba, 0);
  return rtn;
}